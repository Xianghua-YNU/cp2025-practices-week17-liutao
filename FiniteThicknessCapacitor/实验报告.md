# 项目：有限厚平行板电容器电荷分布分析 - 实验报告

**学生姓名：** [赖株涛] **学号：** [20231050070] **完成日期：** [2025/6/18]

## 1. 实验目的

[本实验的学习目标是掌握使用高斯 - 赛德尔超松弛（SOR）方法求解二维拉普拉斯方程，并学会计算电荷密度分布和进行结果可视化。要解决的物理问题是求解有限厚度平行板电容器的拉普拉斯方程，进而得到其电势分布和电荷密度分布。]

## 2. 核心算法

### 2.1 算法思路

[SOR（Successive Over - Relaxation）迭代法是求解拉普拉斯方程的一种迭代算法，其基本思路是在高斯 - 赛德尔迭代的基础上引入松弛因子，以加快收敛速度。以下是实现步骤：
1. 初始化电势网格和导体掩码，设定导体区域的电势值与边界条件（如接地）。
2. 进行迭代更新，对于非导体和边界的内部点，使用SOR更新公式计算新的电势值，该公式结合了旧的电势值和周围点的平均值。
3. 每次迭代计算最大误差，当最大误差小于设定的容差时，认为迭代收敛；若达到最大迭代次数仍未收敛，则发出警告。
4. 最终返回收敛后的电势网格。 ]

### 2.2 关键代码片段

```python
# 请粘贴你认为最重要的核心代码段（如SOR迭代部分）

```

## 3. 实验结果

### 3.1 主要输出

[![QQ_1750217309564](https://github.com/user-attachments/assets/009fe1d7-482a-4784-9b8a-112376d3ac89)
请描述你的程序输出的关键数值结果，如收敛迭代次数、电势范围、电荷分布特征等]

### 3.2 结果验证

[1. 单元测试
单元测试是对软件中的最小可测试单元进行检查和验证，通常使用测试框架来编写和运行测试用例。
```python
# 请粘贴你认为最重要的核心代码段（如SOR迭代部分）
import unittest

def add(a, b):
    return a + b

class TestAdd(unittest.TestCase):
    def test_add(self):
        result = add(2, 3)
        self.assertEqual(result, 5)

if __name__ == '__main__':
    unittest.main()
```
2. 边界条件检查
边界条件是指输入数据的边界值，如最小值、最大值、空值等。验证边界条件可以确保程序在极端情况下仍然能够正常工作。
```python
def get_element_at_index(lst, index):
    if index < 0 or index >= len(lst):
        return None
    return lst[index]

# 测试边界条件
lst = [1, 2, 3]
print(get_element_at_index(lst, 0))  # 正常情况
print(get_element_at_index(lst, 2))  # 最大索引
print(get_element_at_index(lst, 3))  # 越界索引
```
3. 物理合理性分析
如果程序处理的是与物理世界相关的数据，那么结果应该符合物理规律。例如，计算物体的速度、加速度等，结果应该在合理的范围内
```python
def free_fall_velocity(time):
    g = 9.8  # 重力加速度
    if time < 0:
        return 0
    return g * time

# 验证物理合理性
time = 2
velocity = free_fall_velocity(time)
if velocity < 0:
    print("结果不符合物理规律")
else:
    print(f"物体在 {time} 秒后的速度为 {velocity} m/s")
```]

## 4. 问题与收获

### 4.1 主要问题

[请描述在实现过程中遇到的1-2个主要困难或问题]

### 4.2 解决方法

[请描述你是如何解决上述问题的，包括调试方法和解决思路]

### 4.3 主要收获

[请用3-5句话总结通过本实验学到的知识和技能]

## 5. 思考题（可选）

### 5.1 松弛因子影响分析

[请分析不同松弛因子ω对收敛速度的影响，并解释原因]

### 5.2 有限厚度效应

[请对比分析有限厚度与理想薄板电容器在电场分布上的差异]

### 5.3 数值精度讨论

[请讨论网格分辨率对计算精度的影响，以及如何平衡精度与计算效率]
